# 圈地大作战

## 1. 项目概况

#### 1.1 项目背景

​		圈地大作战是一款十分经典且有趣的小游戏，非常考验玩家的反应速度与心理博弈。在游戏中，玩家需要不断增加自己的领地面积的同时保护自己不被对手击杀。

#### 1.2 项目管理

- 版本控制：github
- 开发环境：QT 5.15
- 编程语言：C++17
- 框架结构：MVVM
- 文档编写：MarkDown

#### 1.3 小组信息

- 小组名称：圈地大作战组
- 小组成员：张书祺、骆一博、徐铭
- 选        题：圈地大作战游戏



## 2. 详细功能说明

#### 2.1 功能列表

​		通过键盘实现不同玩家的控制: 

- 玩家一：
  - A：    改变移动方向向左
  - W：   改变移动方向向上
  - D：    改变移动方向向右
  - S：     改变移动方向向下
- 玩家二：
  - ←：   改变移动方向向左
  - ↑：     改变移动方向向上
  - →：   改变移动方向向右
  - ↓：     改变移动方向向下
- 玩家三：
  - 1：     改变移动方向向左
  - 5：     改变移动方向向上
  - 3：     改变移动方向向右
  - 2：     改变移动方向向下
- 玩家四：
  - J：      改变移动方向向左
  - I：      改变移动方向向上
  - L：     改变移动方向向右
  - K：     改变移动方向向下

#### 2.2 界面展示

图片：游戏页面

#### 2.3 游戏目标

​		在倒计时结束时领地最大的玩家获得胜利。

#### 2.4 游戏攻略

- 玩家从自己的领地出发，当再次回到自己的领地时，会将路径所围的格子涂成自己的颜色，玩家得分为自己所属颜色作图成的格子数
- 当玩家操控的角色撞击到另一个玩家的路径上时，会击杀另一玩家，被击杀的玩家的领地会消失。
- 撞上自己的路径会自杀。



## 3. 非功能性需求

#### 3.1 系统需求

- 正确配置Qt后，所有系统都能编译执行。

#### 3.2 性能需求

- 尽量保证用户在进行游戏时不会出现卡顿等影响游戏体验的现象。
- 当前版本只支持单机游戏，但支持2~4人一起游戏。



## 4. 项目规划

#### 4.1 框架描述

​		游戏采用MVVM (Model- View- ViewModel) 架构，主要由视图 (View)、视图模型 (ViewModel)、模型 (Model)、App层四部分组成，通过这四部分实现 UI 逻辑、呈现逻辑和状态控制、数据与业务逻辑的分离，实现了模块的独立开发。

##### 4.1.1 Common

- 声明全局的宏定义。
- 定义枚举类型。
- 定义操作指令类，纯虚类`Commands`作为View中接口。具体的指令是其子类，在ViewModel层中实现。

##### 4.1.2 Model

​		操作实体的内部定义，内部逻辑的实现。实现碰撞检测、人物位置更新等等功能。

- 游戏初始化

​		游戏的数据以数组形式储存在model层，通过共享指针的方式进行传递。游戏初始化功能负责将游戏数据根据玩家输入的游戏信息（玩家人数）初始化。

- 玩家信息更新

​		更新模块负责根据玩家当前的状态更新玩家信息，例如玩家1当前的状态为向上移动，那么每次调用更新模块会将玩家的位置向上更新一格。更新模块还包括了玩家是否撞墙的检测调用，击杀检测调用，复活检测调用，圈地算法调用。每个时钟周期之内玩家信息更新模块会被调用一次，确保玩家最新信息被写进数据里。

- 碰撞检测

​		碰撞检测负责判断玩家是否撞到边界，如果撞到的话会判定玩家死亡并重生该玩家，以及重设玩家的参数。（注意：model层中的玩家状态改变不会发送信号，model层会自己在一个时钟周期内完成信息的修改，保证View Model调用时已经是最新信息）

- 击杀检测

​		击杀检查负责判断玩家是否撞到其他玩家的路径，如果撞到的话就将被撞到的玩家击杀并重生。击杀检测会逐个遍历每个玩家已经走过的但未成环的路径，如果该路径上有其他玩家，那么这个玩家会被击杀并立即重生，同时在一个时钟周期之内移动状态无法改变。

- 重生模块

​		重生模块负责将玩家状态重置为初始状态，在游戏开始时会调用一次重生模块，后面只有在玩家撞墙或者被击杀会调用。

- 圈地算法

​		圈地算法是model层的核心。该算法会首先判定玩家的路径是否闭环，如果形成了闭环则调用算法模块进行领地填充。算法模块主要通过BFS搜索进行，首先根据玩家的已有领地和闭环路径圈出一片搜索范围，然后对该范围内所有没有被搜索过的块进行搜索。搜索过程中，如果遇到本玩家的领地块、路径块、已经搜索定性过的块都会跳过，否则将当前块放入栈中，然后搜索这个块周围的8个块，如果存在外界块则说明刚才栈中所有的块都与外界联通，就将栈中的所有块定性为已搜索的非领地块，栈清空；如果遇到领地块则不会入栈，继续搜索；当再次遇到没有定性的块时，再次执行搜索周围8个块的过程，以此类推直到没有未定性的块，这时说明栈中所有的块都是领地块，将这些块定性并出栈。以此类推直到搜索范围内所有的块都被定性。

##### 4.1.3 View Model

​		将Model层的函数封装成指针类以便于View层调用。

##### 4.1.4 View

​		处理界面反馈逻辑（键盘事件，定时器），以及绘制界面功能。用`command->exec()`的形式在接入Model&View Model层的功能。如果需要访问Model层的数据，在类内定义对应对应的仿函数。如`std::function<QPoint(void)> get_ice_pos`是获取冰人位置的仿函数，在App层再利用lambda表达式，绑定到Model & View Model层提供的访问接口上。

##### 4.1.5 App

​		将View层的共享指针、仿函数绑定到Model&View Model上。

#### 4.2 实现过程

##### 4.2.1 第一轮迭代

- [x] 实现MVVM框架的搭建
- [x] 实现主窗口
- [x] 实现玩家移动方向的修改

##### 4.2.2 第二轮迭代

- [x] 完善游戏地图的UI
- [x] 完成游戏图标
- [x] 完成游戏音乐
- [x] 完成help文档



## 5. 小组分工

- 张书祺
  - Common层实现
  - ViewModel层实现
  - 文档撰写
- 骆一博
  - Model层实现
- 徐铭
  - View层实现
  - App层实现

